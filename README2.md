## Вступление

> **ВАЖНО!!** ВСЕ ДЕЙСТВИЯ ШКОЛЬНИК ДОЛЖЕН ДЕЛАТЬ САМ, ВЫ ЕМУ ПОМОГАЕТЕ ИСКЛЮЧИТЕЛЬНО ИНСТРУКЦИЯМИ И ОБЪЯСНЯЕТЕ ТЕОР. ЧАСТЬ. НИЧЕГО ЗА НЕГО ДЕЛАТЬ НЕ НАДО!!

Помочь можно только в самых крайних случаях:

1. Если испытуемый совсем дерево и даже по клаве не попадает.
    
2. Следите за временем, если он что-то делает сам, но сильно тормозит — можете в некоторых моментах помогать (например, показать, как быстрее копировать и т.д.).  
    Приоритет на то, чтобы показать как можно больше функционала и чтобы человеку было интересно.
    

---

## 1. Общее ознакомление

### 1.1

Вкратце собрать инфу: шарит ли чел, что такое tower_defence, Python.  
Если ответит неуверенно или скажет «нет», то в двух словах объяснить, что это.

### 1.2

Открыть школьнику `main.py`, запустить игру (**обязательно упомянуть, что игру запускаем всегда только с файла `main.py`!!**)

### 1.3

Дать потыркаться, поиграться буквально 2 минуты.  
Проследите, чтобы он попробовал все функции или большинство:

- выбор башни
    
- установка
    
- поставить другой тип башни
    
- увидеть всех врагов и разницу между ними
    
- увидеть, как игра заканчивается (победа/поражение)
    
- пройти много волн
    

---

## 2. Редактирование уровня

### 2.1

Открыть файл `level1.json`, объяснить структуру уровня и возможность менять её под себя.  
Если будет спрашивать, почему там ещё что-то кроме уровня — объяснить, что это для ручной настройки волн, которую попробуем позже.
### 2.2

Дать школьнику поменять уровень, показать, что можно создавать свой кастомный уровень.  
Если создаст какую-то зацикленную хрень и будет спрашивать, почему враг пошёл направо, а не налево — накинуть базы по функции поиска пути.

Объяснить:

- приоритет выбора направления
    
- что считается началом и концом пути
    

---

### Гайд по редактированию уровня

1. В `level1.json` найти `tilemap` и объяснить структуру уровня (`"#"` — дорога, `" "` — трава)
    
2. Объяснить приоритет обхода уровня — **цикл начинает идти по СТРОКАМ**, т.е. путь начинается с той точки, которая **выше**.
![[Pasted image 20250424125050.png]]
    
3. Объяснить приоритет выбора направления противниками:
    
    > вправо → вниз → влево → вверх
    
    Персонаж **не может пойти туда, где уже был**.  
    Если на карте есть круг — он не пойдёт второй раз по нему, даже если конец стоит после круга.
    

**Пример:**
![[Pasted image 20250424125128.png]]
---
## 3. Добавление нового типа врага

### 3.1

Открыть файл `enemy.py`, кратко объяснить структуру классов:

- один базовый
    
- остальные — наследники (меняем параметры врагов быстро и эффективно)
    

>Накидывать базы по ООП и объяснять инкапсулирование, наследование и полиморфизм – не нужно, им это нафиг не надо.

### 3.2

Дать школьнику создать свой собственный тип врага, постараться предложить ему какой-то архитип (супер-быстрый, супер-живучий и т.д.), если сильно хочется то пусть хоть неубиваемую хрень или флеша создаёт.
Главное — чтобы **результат он увидел сам** и **остался доволен**.

---

### Гайд по добавлению нового типа врага

1. В `enemy.py` создаёте новый класс:
    

```python
class ИМЯ_НОВОГО_КЛАССА(BaseEnemy):
    def __init__(self, path, image):
        super().__init__(path, image, health=ХП, speed=СКОРОСТЬ, reward=НАГРАДА)
```

2. В `game.py`в самом начале (где импорт) —добавить новый класс врага:
    

```python
from entities.enemy import BasicEnemy, TankEnemy, FastEnemy, ИМЯ_НОВОГО_КЛАССА
```

3. В `assets/enemies` — школьник выбирает картинку понравившегося противника:

![[Pasted image 20250424125239.png]]
    
4. В `game.py`, блок «Загрузка изображений врагов» добавляете в словарь выбранную картинку врага:
    

```python
enemy_images = {
    "basic": pygame.image.load(...),
    "tank": pygame.image.load(...),
    ...
    "КРАТКОЕ_ИМЯ": pygame.image.load(...),
}
```

5. Блок «Сопоставление типа врага и класса» добавляете в словарь новую запись (связываете созданный класс и выбранную картинку):
    

```python
enemy_classes = {
    "basic": BasicEnemy,
    ...
    "КРАТКОЕ_ИМЯ": ИМЯ_НОВОГО_КЛАССА,
}
```

---

### 6. Работа с волнами

###  **С чем сейчас работаете:**

| **Метод**                           | **Описание**                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Автогенерация волн**              | В `utils.py`, функция `generate_waves(auto_generation, total_waves)`.В блоке добавления врагов добавляется новый враг:<br><br>`enemies.append({`    `"type": "КРАТКОЕ ИМЯ",`    `"count": max(3, int(base_enemies * 0.7))``})`<br><br>Где:<br>**3** — минимальное число врагов этого типа<br>**0.7** — доля от общего количества врагов в волне |
| **Условие появления**               | Чтобы враг появлялся только с определённой волны, используется условие:<br><br>`if wave_num >= 2:`    `enemies.append({`        `"type": "КРАТКОЕ ИМЯ",`        `"count": max(1, int(base_enemies * 0.2))`    `})`<br><br>Где:<br>**1** — минимальное количество<br>**0.2** — доля от общего числа                                              |
| **Настройки, которые можно менять** | Всё остальное делается по такому же принципу, меняется только:<br>- Условие<br>- Количество врагов<br>- Тип врага<br>- Включать ли его в общее число врагов или выделить в отдельную волну<br>- Скорость спавна                                                                                                                                 |

---

### **Ручная настройка волн (`level1.json`)**

В level1,json находите список waves и напрямую добавляете в него новые волны. В каждой волне напрямую добавляете типы врагов, которые там будут, а также их количество (и скорость спавна):

|**Поле**|**Пример**|**Описание**|
|---|---|---|
|`waves`|Массив объектов волн|Каждая волна — отдельный объект|
|`enemies`|`[{"type": "basic", "count": 5}, {"type": "tank", "count": 2}]`|Тип и количество врагов|
|`spawn_rate`|`100`, `60`|Скорость спавна (мс или условные ед.)|

**Пример полной волны:**

```json
{
  "enemies": [
    { "type": "basic", "count": 5 },
    { "type": "tank", "count": 2 }
  ],
  "spawn_rate": 100
}
```

## 4. Добавление нового типа пули

### 4.1

Открыть `bullet.py`, кратко объяснить структуру классов (один базовый, остальные наследники, что позволяет быстро и эффективно менять параметры пуль). Накидывать базы по ООП и объяснять инкапсулирование, наследование и полиморфизм – не нужно, им это нафиг не надо.

### 4.2

Дать школьнику создать свой собственный тип пули (пуле можно настраивать урон и скорость полёта), если сильно хочется, то можно выкрутить урон, главное чтобы он сам результат увидел и доволен был (со скоростью полёта пули лучше сильно не играться, слишком большая – ломает анимацию и пули буквально телепортируются, слишком маленькая – пули не долетают до врагов и «приклеиваются» к ним из-за чего противники умирают позже). Однако если товарищ хочет посмотреть на эти мини баги, то можно показать.

---

### Гайд по добавлению пули

1. В `bullet.py` создаёте новый класс:
    

```python
class ИМЯ_НОВОГО_КЛАССА(BaseBullet):
    def __init__(...):
        super().__init__(...)
        self.speed = СКОРОСТЬ
        self.damage = УРОН
```

2. В `tower.py`в самом начале (где импорт) добавить новый класс пули:
    

```python
from entities.bullet import ..., ИМЯ_НОВОГО_КЛАССА
```

3. Картинка пули в `assets/bullets` школьник выбирает картинку понравившейся пули:

![[Pasted image 20250424125502.png]]
    
4. В `game.py`, "зЗагрузка изображений пуль" добавляете в словарь выбранную картинку пули:
    

```python
bullet_images = {
    "basic": pygame.image.load(...),
    ...
    "КРАТКОЕ_ИМЯ": pygame.image.load(...),
}
```

5. Предлагаете выбрать, добавить новую башню, которая будет стрелять новыми пулями, или просто поменять пулю для уже существующей (первое позволит увидеть связь между пулей и башней, второе – быстрее увидеть результат). С чем сейчас работаете:

### **Добавление/изменение башни и снаряда**

| **Сценарий**                                  | **Описание**                                                                                                                                                                                                                                                                                                                                                                                                                   |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Добавление новой башни с новым снарядом**   | Если вы создаёте **новую башню**, которая будет использовать **новый тип снаряда**, переходите к процессу создания новой башни (новый класс, изображение, логика и т.п.) — т.е. работа с `tower.py` и созданием собственного `Bullet`-класса.                                                                                                                                                                                  |
| **Замена снаряда для уже существующей башни** | В файле `tower.py` находите нужный класс башни и меняете параметр `bullet_class` в конструкторе на нужный класс пули.<br>**Пример:<br>**`python<br>class BasicTower(BaseTower):<br> def __init__(self, x, y, image=None, bullet_img=None):<br> super().__init__(<br> x, y, image,<br> bullet_class=ИМЯ_НОВОГО_КЛАССА_ПУЛИ,<br> bullet_img=bullet_img<br> )<br> self.range = 100<br> self.cooldown = 60<br> self.cost = 50<br>` |


---

## 5. Добавление нового типа башни

### 5.1

Открыть `tower.py`, объяснить структуру. Накидывать базы по ООП и объяснять инкапсулирование, наследование и полиморфизм – не нужно, им это нафиг не надо.

### 5.2

Дать школьнику создать свой собственный тип башни, постараться предложить ему какой-то архитип (башня-снайпер, башня-пулемёт и т.д.), если сильно хочется то пусть создаёт хоть башню, которая через всю карту стреляет или всех с одного выстрела убивает, главное чтобы он сам результат увидел и доволен был.

---

### Гайд по добавлению башни

1. В `tower.py` создаёте новый класс:
    

```python
class ИМЯ_НОВОГО_КЛАССА(BaseTower):
    def __init__(...):
        super().__init__(..., bullet_class=..., ...)
        self.range = ...
        self.cooldown = ...
        self.cost = ...
```

2. В `game.py` в самом начале (где импорт)  — добавить новый класс башни:
    

```python
from entities.tower import ..., ИМЯ_НОВОГО_КЛАССА
```

3. В `assets/towers` — школьник выбирает картинку понравившейся башни:

![[Pasted image 20250424125532.png]]
    
4. В `game.py` «Загрузка изображений башен» добавляете в словарь выбранную картинку башни:
    

```python
tower_images = {
    ...
    "КРАТКОЕ_ИМЯ": pygame.image.load(...),
}
```

5. В game.py в блоке «Сопоставление типа башни и класса» добавляете в словарь новую запись (связываете созданный класс и выбранную картинку):
    

```python
tower_classes = {
    ...
    "КРАТКОЕ_ИМЯ": ИМЯ_НОВОГО_КЛАССА,
}
```

---

## 6. Переключение режима генерации волн

### 6.1

Показать школьнику возможность переключения режима генерации волн: автогенерация и ручная настройка.

### 6.2

Продемонстрировать, что при автогенерации можно легко увеличивать число волн и настраивать кол-во противников в волне, скорость их спавна и даже появление с конкретной волны или на конкретных волнах (см. пункт добавление нового врага).
### Гайд по смене режима генерации волн

1. В `game.py` находите блок «Игровые переменные» и демонстрируете, что здесь можно увеличить количество автогенерируемых волн и здесь же отключается автогенерация:

```python
# === Игровые переменные ===
auto_generation = True
total_waves = 10
```

2. Дайте школьнику поиграть с числом волн и их настройками (например, увеличить скорость спавна определённых типов врагов, добавить нового моба, увеличить общую прибавку противников в волне и т.д.) Здесь всё перекликается с пунктом добавления нового врага, если он уже что-то пробовал – повторять не надо, покажите что-то новое (см пункт добавления нового врага, подпункт 6 автогенерация волн):

```python
from entities.tower import ..., ИМЯ_НОВОГО_КЛАССА
```

3. Отключите автогенерацию и продемонстрируйте ручную настройку волн.
    
4. Откройте level1.json и покажите, как именно задаются волны (см пункт добавления нового врага, подпункт 6 ручная настройка волн):
    

```python
    "advanced": AdvancedTower,

    "КРАТКОЕ ИМЯ": ИМЯ НОВОГО КЛАССА БАШНИ,
}
```

---

## 7. Отпустите в свободное плавание

### 7.1

После того, как всё показали, если очереди из людей нет, и абитуриент хочет дальше сам тыкаться – дайте ему редачить уже самостоятельно.

### 7.2

В этот период вы также остаётесь рядом с ним и следите, что он делает. Во-первых, это нужно для того, чтобы подсказывать ему. Навряд ли он запомнит весь объём инфы, который вы рассказали ему по предыдущем пунктам. Он может забыть, где лежат картинки, что надо делать чтобы добавить своего врага/башню и т.д. Ваша задача оперативно подсказать ему, чтобы он не тратил время на поиски. Во-вторых, это нужно для того, чтобы если он где-то облажается вы могли быстро найти ошибку и откатить её. Т. к. если вы не следили за изменениями в коде, то иногда бывает трудно понять, где была совершена ошибка, а они сами вам ничего не скажут, потому что тупо не поймут, где накосячили.

---

### Финальные советы

Порядок проведения мастер-класса выстроен логически, **но вы можете менять его**.  
Лучше **спросить у школьника**, с чего он хочет начать.  
Всем удачи!
